create type developers as table
(
    developer int
)
go

create type roles as table
(
    role int
)
go

create table COMPLAINT_STATUS
(
    statusName varchar(10),
    statusID   int not null
        constraint COMPLAINT_STATUS_pk
            primary key nonclustered
)
go

create table OTP
(
    otpID   int not null
        constraint OTP_pk
            primary key nonclustered,
    otpCode int
)
go

create table ROLE
(
    roleID   int not null
        constraint ROLE_pk
            primary key nonclustered,
    roleName varchar(25)
)
go

create unique index ROLE_roleID_uindex
    on ROLE (roleID)
go

create table USERS
(
    userID        int         not null
        constraint USERS_pk
            primary key nonclustered,
    userEmail     varchar(50) not null,
    password      varchar(100),
    firstName     varchar(40),
    lastName      varchar(40),
    contactNumber varchar(20),
    activeStatus  bit,
    lastLogin     datetime,
    createdBy     varchar(50),
    createdAt     datetime,
    modifiedBy    varchar(50),
    modifiedAt    datetime
)
go

create table ACTIVE_SESSION
(
    userID     int
        constraint ACTIVE_SESSION_USERS_userID_fk
            references USERS,
    lastActive bigint
)
go

create table PRODUCT
(
    productID            int not null
        constraint PRODUCT_pk
            primary key nonclustered,
    productName          varchar(40),
    category             varchar(20),
    customerID           int
        constraint PRODUCT_USERS_userID_fk_2
            references USERS,
    projectManagerID     int
        constraint PRODUCT_USERS_userID_fk_3
            references USERS,
    accountCoordinatorID int
        constraint PRODUCT_USERS_userID_fk
            references USERS,
    createdAt            datetime,
    createdBy            int,
    modifiedAt           datetime,
    modifiedBy           int
)
go

create table ALLOCATION
(
    developerID int not null
        constraint ALLOCATION_USERS_userID_fk
            references USERS,
    productID   int not null
        constraint ALLOCATION_PRODUCT_productID_fk
            references PRODUCT,
    constraint ALLOCATION_pk
        primary key nonclustered (developerID, productID)
)
go

create table CHANGINGHISTORY
(
    productID     int
        constraint CHANGINGHISTORY_PRODUCT_productID_fk
            references PRODUCT
            on delete cascade,
    submittedtime datetime,
    exAcID        int,
    preAcID       int,
    newAcID       int,
    doneBy        varchar(20),
    action        varchar(20),
    exAcName      varchar(40),
    preAcName     varchar(40),
    newAcName     varchar(40),
    readStatus    bit
)
go

create table COMPLAINT
(
    complaintID       int not null,
    subComplaintID    int not null,
    description       varchar(5000),
    status            int
        constraint COMPLAINT_COMPLAINT_STATUS_statusID_fk
            references COMPLAINT_STATUS,
    submittedDate     datetime,
    lastDateOfPending datetime,
    wipStartDate      datetime,
    finishedDate      datetime,
    productID         int
        constraint COMPLAINT_PRODUCT_productID_fk
            references PRODUCT
            on update cascade,
    acViewedStatus    bit,
    constraint COMPLAINT_pk
        primary key nonclustered (complaintID, subComplaintID)
)
go

create table COMMENT
(
    complaintID     int not null,
    commentID       int not null,
    isImage         bit,
    textOrImageName varchar(max),
    senderID        int
        constraint COMMENT_USERS_userID_fk
            references USERS,
    submittedTime   datetime,
    subComplaintID  int not null,
    constraint COMMENT_pk
        primary key nonclustered (complaintID, commentID),
    constraint COMMENT_COMPLAINT_complaintID_subComplaintID_fk
        foreign key (complaintID, subComplaintID) references COMPLAINT
)
go

create table COMPLAINT_ATTACHMENT_DETAILS
(
    complaintID    int not null,
    subComplaintID int not null,
    imageIndex     int not null,
    imageName      varchar(max),
    constraint COMPLAINT_ATTACHMENT_DETAILS_pk
        primary key nonclustered (complaintID, subComplaintID, imageIndex),
    constraint COMPLAINT_ATTACHMENT_DETAILS_COMPLAINT_complaintID_subComplaintID_fk
        foreign key (complaintID, subComplaintID) references COMPLAINT
            on update cascade on delete cascade
)
go

create table FEEDBACK
(
    complaintID    int not null
        constraint FEEDBACK_pk
            primary key nonclustered,
    satisfaction   int,
    description    varchar(1000),
    subComplaintID int not null,
    constraint FEEDBACK_COMPLAINT_complaintID_subComplaintID_fk
        foreign key (complaintID, subComplaintID) references COMPLAINT
            on update cascade
)
go

create table TASK
(
    taskID               varchar(10) not null
        constraint TASK_pk
            primary key nonclustered,
    complaintID          int,
    subComplaintID       int,
    assignDate           datetime,
    deadline             datetime,
    completed            bit,
    accountCoordinatorID int
        constraint TASK_USERS_userID_fk
            references USERS,
    developerID          int
        constraint TASK_USERS_userID_fk_2
            references USERS,
    constraint TASK_COMPLAINT_complainID_subComplaintID_fk
        foreign key (complaintID, subComplaintID) references COMPLAINT
)
go

create unique index USERS_userEmail_uindex
    on USERS (userEmail)
go

create table USER_ROLE
(
    userID    int not null
        constraint USER_ROLE_USERS_userID_fk
            references USERS,
    roleID    int not null
        constraint USER_ROLE_ROLE_roleID_fk
            references ROLE,
    [default] bit not null,
    constraint USER_ROLE_pk
        primary key nonclustered (roleID, userID)
)
go

create view Ayoma_Developers AS
select u.userID,
       u.userEmail,
       u.firstName,
       u.lastName,
       u.contactNumber,
       u.activeStatus,
       u.password,
       ur.roleID,
       ur.[default],
       r.roleName
from USERS u,
     USER_ROLE ur,
     Role r
where u.userID = ur.userID
  AND ur.roleID = r.roleID
  AND r.roleName = 'developer'
go

create view view_ac as
select u.userEmail, u.firstName, u.lastName, u.userID
from USERS u,
     USER_ROLE r
where u.userID = r.userID
  and r.roleID = '1'
go

CREATE function SelectRole(@role_input varchar)
    Returns int
AS
BEGIN

    if (@role_input = 'Admin')
        begin
            return 5
        end
    if (@role_input = 'Customer')
        begin
            return 0
        end
    if (@role_input = 'Account Coordinator')
        begin
            return 1
        end
    if (@role_input = 'Developer')
        begin
            return 2
        end
    if (@role_input = 'Project Manager')
        begin
            return 3
        end
    if (@role_input = 'CEO')
        begin
            return 4
        end
    return -1
END
go

CREATE procedure checkUserSession @userID int, @time bigint as
    if exists(select 1
              from ACTIVE_SESSION
              where userID = @userID)
        begin
            declare @lastActive bigint
            select @lastActive = lastActive from ACTIVE_SESSION where userID = @userID
            if (@time - @lastActive < 7200000)
--         if (@time - @lastActive < 10000)
                begin
                    update ACTIVE_SESSION set lastActive = @time where userID = @userID
                    return 0;
                end
            else
                begin
                    return 1;
                end
        end
    else
        begin
            return -1;
        end
go

CREATE procedure checkUsername @username varchar(50) as
begin
    if exists(select 1 from USERS where userEmail = @username)
        begin
            select r.roleName
            from users u,
                 ROLE r,
                 USER_ROLE ur
            where u.userEmail = @username
              and u.userID = ur.userID
              and r.roleID = ur.roleID
              and ur.[default] = 1;
            select userEmail username, password, userID, firstName, lastName from USERS where userEmail = @username;
            return 0;
        end
    else
        begin
            return -1;
        end
end
go

CREATE PROCEDURE createFeedback @_complaintID int,
                                @_feedback varchar(5000),
                                @_ratedValue int
AS
    BEGIN TRANSACTION

INSERT INTO FEEDBACK
VALUES (@_complaintID,
        @_ratedValue,
        @_feedback,
        0)
    IF @@ROWCOUNT = 0 GOTO errorHandler;

UPDATE COMPLAINT
SET status = 3
where complaintID = @_complaintID
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure deleteSelectedComplaint @_complaintID int
as
    BEGIN TRANSACTION
DECLARE @complaintIDTemp int, @subComplaintIDTemp int, @commentIDTemp int, @imageIndexTemp int, @taskIDTemp int
DECLARE
    comments_cursor CURSOR LOCAL FOR SELECT complaintID, commentID
                                     FROM COMMENT
                                     WHERE complaintID = @_complaintID
DECLARE
    complaintAttachment_cursor CURSOR LOCAL FOR SELECT complaintID, imageIndex
                                                FROM COMPLAINT_ATTACHMENT_DETAILS
                                                WHERE complaintID = @_complaintID
DECLARE
    tasks_cursor CURSOR LOCAL FOR SELECT taskID, complaintID
                                  FROM TASK
                                  WHERE complaintID = @_complaintID
DECLARE
    complaints_cursor CURSOR LOCAL FOR SELECT complaintID, subComplaintID
                                       FROM COMPLAINT
                                       WHERE complaintID = @_complaintID
    if exists(select 1
              from COMPLAINT
              where complaintID = @_complaintID)
        begin
            if exists(select 1
                      from COMMENT
                      where complaintID = @_complaintID)
                begin

                    select * from COMMENT where complaintID = @_complaintID and isImage = 1

                    OPEN comments_cursor
                    fetch next from comments_cursor into @complaintIDTemp, @commentIDTemp

                    while @@fetch_status = 0
                        begin
                            delete from COMMENT where complaintID = @complaintIDTemp AND commentID = @commentIDTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from comments_cursor into @complaintIDTemp, @commentIDTemp
                        end
                    CLOSE comments_cursor

                end

            if exists(select 1
                      from COMPLAINT_ATTACHMENT_DETAILS
                      where complaintID = @_complaintID)
                begin
                    SELECT * from COMPLAINT_ATTACHMENT_DETAILS where complaintID = @_complaintID

                    OPEN complaintAttachment_cursor
                    fetch next from complaintAttachment_cursor into @complaintIDTemp, @imageIndexTemp

                    while @@fetch_status = 0
                        begin
                            delete
                            from COMPLAINT_ATTACHMENT_DETAILS
                            where complaintID = @complaintIDTemp AND imageIndex = @imageIndexTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from complaintAttachment_cursor into @complaintIDTemp, @imageIndexTemp
                        end
                    CLOSE complaintAttachment_cursor

                end

            if exists(select 1
                      from FEEDBACK
                      where complaintID = @_complaintID)
                begin
                    Delete from FEEDBACK where complaintID = @_complaintID
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                end

            if exists(select 1
                      from TASK
                      where complaintID = @_complaintID)
                begin

                    OPEN tasks_cursor
                    fetch next from tasks_cursor into @taskIDTemp ,@complaintIDTemp

                    while @@fetch_status = 0
                        begin
                            delete from TASK where taskID = @taskIDTemp AND complaintID = @complaintIDTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from tasks_cursor into @taskIDTemp, @complaintIDTemp
                        end
                    CLOSE tasks_cursor

                end

            OPEN complaints_cursor
            fetch next from complaints_cursor into @complaintIDTemp, @subComplaintIDTemp

            while @@fetch_status = 0
                begin
                    delete from COMPLAINT where complaintID = @complaintIDTemp AND subComplaintID = @subComplaintIDTemp
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                    fetch next from complaints_cursor into @complaintIDTemp, @subComplaintIDTemp
                end
            CLOSE complaints_cursor
            COMMIT TRANSACTION
            RETURN 0;
        end
    else
        begin
            ROLLBACK TRANSACTION
            RETURN -2;
        end
    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure deleteSelectedProduct @_productID int
as
    BEGIN TRANSACTION
DECLARE
    @_complaintID int, @complaintIDTemp int, @subComplaintIDTemp int, @commentIDTemp int, @imageIndexTemp int, @taskIDTemp int, @productIDTemp int, @developerIDTemp int
DECLARE
    allocations_cursor CURSOR LOCAL FOR SELECT developerID, productID
                                        FROM ALLOCATION
                                        WHERE productID = @_productID

    -- check whether is there any complaint with product which is going to be deleted and if exists then first of all delete those complaints with it's all
    -- child data.(comments,complaint attachments details,feedbacks,tasks)
    if exists(select 1
              from COMPLAINT
              where productID = @_productID)
        begin
            SELECT @_complaintID = complaintID FROM COMPLAINT where productID = @_productID
            DECLARE comments_cursor CURSOR LOCAL FOR SELECT complaintID, commentID
                                                     FROM COMMENT
                                                     WHERE complaintID = @_complaintID
            DECLARE complaintAttachment_cursor CURSOR LOCAL FOR SELECT complaintID, imageIndex
                                                                FROM COMPLAINT_ATTACHMENT_DETAILS
                                                                WHERE complaintID = @_complaintID
            DECLARE tasks_cursor CURSOR LOCAL FOR SELECT taskID, complaintID FROM TASK WHERE complaintID = @_complaintID
            DECLARE complaints_cursor CURSOR LOCAL FOR SELECT complaintID, subComplaintID
                                                       FROM COMPLAINT
                                                       WHERE complaintID = @_complaintID

            if exists(select 1
                      from COMMENT
                      where complaintID = @_complaintID)
                begin

                    select * from COMMENT where complaintID = @_complaintID and isImage = 1

                    OPEN comments_cursor
                    fetch next from comments_cursor into @complaintIDTemp, @commentIDTemp

                    while @@fetch_status = 0
                        begin
                            delete from COMMENT where complaintID = @complaintIDTemp AND commentID = @commentIDTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from comments_cursor into @complaintIDTemp, @commentIDTemp
                        end
                    CLOSE comments_cursor

                end

            if exists(select 1
                      from COMPLAINT_ATTACHMENT_DETAILS
                      where complaintID = @_complaintID)
                begin
                    SELECT * from COMPLAINT_ATTACHMENT_DETAILS where complaintID = @_complaintID

                    OPEN complaintAttachment_cursor
                    fetch next from complaintAttachment_cursor into @complaintIDTemp, @imageIndexTemp

                    while @@fetch_status = 0
                        begin
                            delete
                            from COMPLAINT_ATTACHMENT_DETAILS
                            where complaintID = @complaintIDTemp AND imageIndex = @imageIndexTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from complaintAttachment_cursor into @complaintIDTemp, @imageIndexTemp
                        end
                    CLOSE complaintAttachment_cursor

                end

            if exists(select 1
                      from FEEDBACK
                      where complaintID = @_complaintID)
                begin
                    Delete from FEEDBACK where complaintID = @_complaintID
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                end

            if exists(select 1
                      from TASK
                      where complaintID = @_complaintID)
                begin

                    OPEN tasks_cursor
                    fetch next from tasks_cursor into @taskIDTemp ,@complaintIDTemp

                    while @@fetch_status = 0
                        begin
                            delete from TASK where taskID = @taskIDTemp AND complaintID = @complaintIDTemp
                            IF @@ROWCOUNT = 0 GOTO errorHandler;
                            fetch next from tasks_cursor into @taskIDTemp, @complaintIDTemp
                        end
                    CLOSE tasks_cursor

                end

            OPEN complaints_cursor
            fetch next from complaints_cursor into @complaintIDTemp, @subComplaintIDTemp

            while @@fetch_status = 0
                begin
                    delete from COMPLAINT where complaintID = @complaintIDTemp AND subComplaintID = @subComplaintIDTemp
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                    fetch next from complaints_cursor into @complaintIDTemp, @subComplaintIDTemp
                end
            CLOSE complaints_cursor
        end
    -- end of the if statenment
    if exists(select 1
              from ALLOCATION
              where productID = @_productID)
        begin
            OPEN allocations_cursor
            fetch next from allocations_cursor into @developerIDTemp ,@productIDTemp

            while @@fetch_status = 0
                begin
                    delete from ALLOCATION where productID = @productIDTemp AND developerID = @developerIDTemp
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                    fetch next from allocations_cursor into @developerIDTemp, @productIDTemp
                end
            CLOSE allocations_cursor
        end

delete
from PRODUCT
where productID = @_productID
    COMMIT transaction
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure deleteSelectedUser @_username VARCHAR(50)
as
    BEGIN TRANSACTION
DECLARE @userIDTemp int, @roleIDTemp int, @userID int
SELECT @userID = userID
FROM USERS
where userEmail = @_username;
DECLARE
    cursor_email CURSOR LOCAL FOR SELECT userID, roleID
                                  FROM USER_ROLE
                                  WHERE userID = @userID
    if exists(select 1
              from PRODUCT
              where customerID = @userID)
        begin
            select productID, productName from PRODUCT where customerID = @userID
            ROLLBACK TRANSACTION
            RETURN -2;
        end
    if exists(select 1
              from PRODUCT
              where accountCoordinatorID = @userID)
        begin
            select productID, productName from PRODUCT where accountCoordinatorID = @userID
            ROLLBACK TRANSACTION
            RETURN -3;
        end
    if exists(select 1
              from PRODUCT
              where projectManagerID = @userID)
        begin
            select productID, productName from PRODUCT where projectManagerID = @userID
            ROLLBACK TRANSACTION
            RETURN -4;
        end
    if exists(select 1
              from ALLOCATION
              where developerID = @userID)
        begin
            select P.productID, productName
            from ALLOCATION A
                     join PRODUCT P on P.productID = A.productID
            where developerID = @userID
            ROLLBACK TRANSACTION
            RETURN -4;
        end
    if exists(select 1
              from ACTIVE_SESSION
              where userID = @userID)
        begin
            DELETE from ACTIVE_SESSION where userID = @userID
        end
    if exists(select 1
              from USERS
              where userEmail = @_username)
        begin

            OPEN cursor_email
            fetch next from cursor_email into @userIDTemp, @roleIDTemp

            while @@fetch_status = 0
                begin
                    delete from USER_ROLE where userID = @userIDTemp AND roleID = @roleIDTemp
                    IF @@ROWCOUNT = 0 GOTO errorHandler;
                    fetch next from cursor_email into @userIDTemp, @roleIDTemp
                end

            DELETE FROM USERS WHERE userEmail = @_username;
            IF @@ROWCOUNT = 0 GOTO errorHandler;
            CLOSE cursor_email
            COMMIT TRANSACTION
            RETURN 0;
        end
    else
        begin
            GOTO errorHandler;
        end
    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE PROCEDURE forgotPasswordChange @_email VARCHAR(50),
                                      @_newPassword VARCHAR(100),
                                      @_clientOtp INT,
                                      @_generatedOtpID INT
AS
    BEGIN TRANSACTION
DECLARE @userID int, @role INT, @generatedOTPValue int;

SELECT @generatedOTPValue = otpCode
FROM OTP
where otpID = @_generatedOtpID;
    -- delete otp record from the OTP table
Delete
from OTP
where otpID = @_generatedOtpID
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    if (@_clientOtp != @generatedOTPValue)
        begin
            ROLLBACK TRANSACTION
            return -2;
        end
    else
        if not exists(select 1 from USERS where userEmail = @_email)
            begin
                ROLLBACK TRANSACTION
                return -3;
            end
UPDATE USERS
SET password = @_newPassword
where userEmail = @_email
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure getComplaintCount
as
begin
    SELECT count(*) as alll FROM COMPLAINT
    select count(*) as pen from COMPLAINT where status = '0'
    select count(*) as work from COMPLAINT where status = '1'
    select count(*) as fin from COMPLAINT where status = '2'
    select count(*) as clos from COMPLAINT where status = '3'
    return 0;
end
go

CREATE procedure getComplaintCountForPM(@_pmEmail VARCHAR(50))
as
begin
    select COUNT(*) as alll
    from COMPLAINT c,
         PRODUCT p
    where p.productID = c.productID
      and p.projectManagerID = (select userID from USERS where userEmail = @_pmEmail)

    select COUNT(*) as pen
    from COMPLAINT c,
         PRODUCT p
    where p.productID = c.productID
      and p.projectManagerID = (select userID from USERS where userEmail = @_pmEmail)
      and c.status = '0'

    select COUNT(*) as work
    from COMPLAINT c,
         PRODUCT p
    where p.productID = c.productID
      and p.projectManagerID = (select userID from USERS where userEmail = @_pmEmail)
      and c.status = '1'

    select COUNT(*) as fin
    from COMPLAINT c,
         PRODUCT p
    where p.productID = c.productID
      and p.projectManagerID = (select userID from USERS where userEmail = @_pmEmail)
      and c.status = '2'

    select COUNT(*) as clos
    from COMPLAINT c,
         PRODUCT p
    where p.productID = c.productID
      and p.projectManagerID = (select userID from USERS where userEmail = @_pmEmail)
      and c.status = '3'
    return 0;
end
go

CREATE procedure getCustomerComplaintsByStatusID @_customerEmail VARCHAR(50),
                                                 @_reqComplaintsStatus int
as

DECLARE @customerID int;
SELECT @customerID = userID
FROM USERS
where userEmail = @_customerEmail;
    if exists(select 1
              from COMPLAINT c)
        begin
            if (@_reqComplaintsStatus = -1)
                BEGIN
                    select *
                    from COMPLAINT C
                             JOIN PRODUCT P ON C.productID = P.productID
                    where C.subComplaintID != 0
                      and P.customerID = @customerID
                    select *
                    from COMPLAINT C
                             JOIN PRODUCT P ON C.productID = P.productID
                    where C.subComplaintID = 0
                      and P.customerID = @customerID
                    RETURN 0;
                END
            else
                if (@_reqComplaintsStatus = 0)
                    BEGIN
                        select *
                        from COMPLAINT C
                                 JOIN PRODUCT P ON C.productID = P.productID
                        where C.subComplaintID != 0
                          and P.customerID = @customerID

                        select *
                        from COMPLAINT C
                                 JOIN PRODUCT P ON C.productID = P.productID
                        where C.subComplaintID = 0
                          and P.customerID = @customerID
                          and C.status = 0
                        RETURN 0;
                    END
                else
                    if (@_reqComplaintsStatus = 1)
                        BEGIN
                            select *
                            from COMPLAINT C
                                     JOIN PRODUCT P ON C.productID = P.productID
                            where C.subComplaintID != 0
                              and P.customerID = @customerID

                            select *
                            from COMPLAINT C
                                     JOIN PRODUCT P ON C.productID = P.productID
                            where C.subComplaintID = 0
                              and P.customerID = @customerID
                              and C.status = 1
                            RETURN 0;
                        END
                    else
                        if (@_reqComplaintsStatus = 2)
                            BEGIN
                                select *
                                from COMPLAINT C
                                         JOIN PRODUCT P ON C.productID = P.productID
                                where C.subComplaintID != 0
                                  and P.customerID = @customerID

                                select *
                                from COMPLAINT C
                                         JOIN PRODUCT P ON C.productID = P.productID
                                where C.subComplaintID = 0
                                  and P.customerID = @customerID
                                  and C.status = 2
                                RETURN 0;
                            END
                        else
                            if (@_reqComplaintsStatus = 3)
                                BEGIN
                                    select *
                                    from COMPLAINT C
                                             JOIN PRODUCT P ON C.productID = P.productID
                                    where C.subComplaintID != 0
                                      and P.customerID = @customerID

                                    select *
                                    from COMPLAINT C
                                             JOIN PRODUCT P ON C.productID = P.productID
                                    where C.subComplaintID = 0
                                      and P.customerID = @customerID
                                      and C.status = 3
                                    RETURN 0;
                                END
            RETURN 0;
        end
    else
        begin
            RETURN -1;
        end
go

CREATE procedure getFeedbackCount
as
begin
    select COUNT(*) as sat1 from FEEDBACK where satisfaction = '1'
    select COUNT(*) as sat2 from FEEDBACK where satisfaction = '2'
    select COUNT(*) as sat3 from FEEDBACK where satisfaction = '3'
    select COUNT(*) as sat4 from FEEDBACK where satisfaction = '4'
    select COUNT(*) as sat5 from FEEDBACK where satisfaction = '5'
    return 0;
end
go

CREATE procedure getNotification @_username VARCHAR(50)
as
DECLARE @userID int;
SELECT @userID = userID
FROM USERS
where userEmail = @_username;
begin
    select *
    from CHANGINGHISTORY
    where (exAcID = @userID OR preAcID = @userID OR newAcID = @userID)
      AND readStatus = 'false'
    order by submittedtime DESC
    return @userID;
end
go

CREATE procedure getSelectedComplaintDetailsAdmin(@_complaintID int,
                                                  @_subComplaintID int)
as
    if exists(select 1
              from COMPLAINT
              where complaintID = @_complaintID
                and subComplaintID = @_subComplaintID)
        begin
            select * from COMPLAINT where complaintID = @_complaintID and subComplaintID = @_subComplaintID

            select statusName
            from COMPLAINT_STATUS C_S
                     JOIN COMPLAINT C on C_S.statusID = C.status
            where c.complaintID = @_complaintID
              and c.subComplaintID = @_subComplaintID

            select productName
            from PRODUCT P
                     JOIN COMPLAINT C2 on P.productID = C2.productID
            where C2.complaintID = @_complaintID
              and C2.subComplaintID = @_subComplaintID

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.projectManagerID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = @_subComplaintID)

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.accountCoordinatorID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = @_subComplaintID)

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.customerID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = @_subComplaintID)

            select *
            from COMPLAINT_ATTACHMENT_DETAILS
            where complaintID = @_complaintID and subComplaintID = @_subComplaintID

            return 0;
        end
    else
        begin
            RETURN -1;
        end
go

CREATE procedure getSelectedComplaintDetailsCustomer @_customerEmail VARCHAR(50),
                                                     @_complaintID int,
                                                     @_subComplaintID int
as
DECLARE @customerID int;
SELECT @customerID = userID
FROM USERS
where userEmail = @_customerEmail;
    if (@customerID = (select customerID
                       from PRODUCT P
                                join COMPLAINT C3 on P.productID = C3.productID
                       where C3.complaintID = @_complaintID
                         and c3.subComplaintID = @_subComplaintID))
        begin
            select * from COMPLAINT where complaintID = @_complaintID and subComplaintID = @_subComplaintID
            select statusName
            from COMPLAINT_STATUS CS
                     JOIN COMPLAINT C on CS.statusID = C.status
            where C.complaintID = @_complaintID
              and C.subComplaintID = @_subComplaintID
            select productName
            from PRODUCT P
                     join COMPLAINT C2 on P.productID = C2.productID
            where C2.complaintID = @_complaintID
              and C2.subComplaintID = @_subComplaintID
            select userEmail, firstName, lastName
            from USERS U
            where userID = (select projectManagerID
                            from PRODUCT P
                                     join COMPLAINT C2 on P.productID = C2.productID
                            where C2.complaintID = @_complaintID
                              and C2.subComplaintID = @_subComplaintID)
            select userEmail, firstName, lastName
            from USERS U
            where userID = (select accountCoordinatorID
                            from PRODUCT P
                                     join COMPLAINT C2 on P.productID = C2.productID
                            where C2.complaintID = @_complaintID
                              and C2.subComplaintID = @_subComplaintID)
            select *
            from COMPLAINT_ATTACHMENT_DETAILS
            where complaintID = @_complaintID and subComplaintID = @_subComplaintID
            RETURN 0;
        end
    else
        begin
            RETURN 1;
        end
go

CREATE procedure getSelectedFeedbackDetails(@_complaintID int)
as
    if exists(select 1
              from FEEDBACK
              where complaintID = @_complaintID
                and subComplaintID = 0)
        begin
            select * from FEEDBACK where complaintID = @_complaintID and subComplaintID = 0

            select P.productID, P.productName
            from PRODUCT P
                     JOIN COMPLAINT C2 on P.productID = C2.productID
            where C2.complaintID = @_complaintID
              and C2.subComplaintID = 0

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.projectManagerID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = 0)

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.accountCoordinatorID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = 0)

            select userEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.customerID
            where P2.productID = (select P.productID
                                  from PRODUCT P
                                           JOIN COMPLAINT C2 on P.productID = C2.productID
                                  where C2.complaintID = @_complaintID
                                    and C2.subComplaintID = 0)

            select * from COMPLAINT where complaintID = @_complaintID and subComplaintID = 0

            select COUNT(subComplaintID) as nOfSubComplaints
            from COMPLAINT
            where complaintID = @_complaintID and subComplaintID != 0

            return 0;
        end
    else
        begin
            return -1;
        end
go

CREATE procedure getSelectedProductDetails(@_productID int)
as
    if exists(select 1
              from PRODUCT
              where productID = @_productID)
        begin
            select * from PRODUCT where productID = @_productID
            select userEmail customerEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P1 on USR.userID = P1.customerID
            where P1.productID = @_productID
            select userEmail projectManagerEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P2 on USR.userID = P2.projectManagerID
            where P2.productID = @_productID
            select userEmail accountCoordinatorEmail, firstName, lastName
            from USERS USR
                     JOIN PRODUCT P3 on USR.userID = P3.accountCoordinatorID
            where P3.productID = @_productID

            select complaintID, submittedDate from COMPLAINT where productID = @_productID and subComplaintID = 0
            RETURN 0;
        end
    else
        begin
            RETURN -1;
        end
go

CREATE procedure getSelectedUserDetails @_username VARCHAR(50)
as
DECLARE @userID int;
SELECT @userID = userID
FROM USERS
where userEmail = @_username;

    if exists(select 1
              from USERS
              where userEmail = @_username) and
       exists(select 1
              from USER_ROLE ur
              where ur.userID = @userID
                and ur.[default] = 'true')
        begin
            select * from USERS where userEmail = @_username
            select ur.roleID from USER_ROLE ur where ur.userID = @userID;
            select ur.roleID from USER_ROLE ur where ur.userID = @userID and ur.[default] = 'true';

            select productID, 'Customer' as roleName from PRODUCT where customerID = @userID
            select productID, 'Project Manager' as roleName from PRODUCT where projectManagerID = @userID
            select productID, 'Account Coordinator' as roleName from PRODUCT where accountCoordinatorID = @userID
            select productID, 'Developer' as roleName from ALLOCATION where developerID = @userID

            RETURN 0;
        end
    else
        begin
            RETURN -1;
        end
go

CREATE procedure getSubComplaintsOfSelectedComplain @_complainId VARCHAR(10)
as
    if exists(select 1
              from COMPLAINT c
              where c.complaintID = @_complainId
                and c.subComplaintID != 0)
        begin
            select * from COMPLAINT where subComplaintID != 0 and complaintID = @_complainId
            RETURN 0;
        end
    else
        begin
            RETURN 1;
        end
go

CREATE PROCEDURE lodgeComplaint @_customerEmail varchar(50),
                                @_productID int,
                                @_description varchar(5000),
                                @_noOfImages int
AS
    BEGIN TRANSACTION

DECLARE @currentMaxComplaintID int;
DECLARE @complaintID int;
    SET @currentMaxComplaintID = (SELECT MAX(complaintID)
                                  from COMPLAINT) ;
    SET @complaintID = iif(@currentMaxComplaintID is null, 1, @currentMaxComplaintID + 1);

INSERT INTO COMPLAINT
VALUES (@complaintID,
        0,
        @_description,
        0,
        GETDATE(),
        (SELECT DATEADD(day, 2, GETDATE()) AS DateAdd),
        null,
        null,
        @_productID,
        0)
    IF @@ROWCOUNT = 0 GOTO errorHandler;

DECLARE @i int;
    SET @i = 0;
    WHILE @i < @_noOfImages
        BEGIN
            SET @i = @i + 1
            /* your code*/
            INSERT INTO COMPLAINT_ATTACHMENT_DETAILS
            VALUES (@complaintID, 0, @i, TRIM(STR(@complaintID)) + '-' + '0' + '-' + TRIM(STR(@i)) + '.png')
            IF @@ROWCOUNT = 0 GOTO errorHandler;
        END

SELECT *
FROM COMPLAINT_ATTACHMENT_DETAILS
WHERE complaintID = @complaintID
  and subComplaintID = 0;

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE PROCEDURE lodgeSubComplaint @_complaintID int,
                                   @_subComplaintDesc varchar(5000)
AS
    BEGIN TRANSACTION
DECLARE
    @subComplaintID int;
    SET @subComplaintID = ((SELECT MAX(subComplaintID)
                            from COMPLAINT
                            where complaintID = @_complaintID) + 1);

INSERT INTO COMPLAINT
VALUES (@_complaintID,
        iif(@subComplaintID is null, 1, @subComplaintID),
        @_subComplaintDesc,
        0,
        GETDATE(),
        (SELECT DATEADD(day, 2, GETDATE()) AS DateAdd),
        null,
        null,
        (SELECT productID from COMPLAINT where complaintID = @_complaintID and subComplaintID = 0),
        0)
    IF @@ROWCOUNT = 0 GOTO errorHandler;

UPDATE COMPLAINT
SET status = 0
where complaintID = @_complaintID
  and subComplaintID = 0
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure login @_email VARCHAR(50),
                       @_password VARCHAR(20)
as
    BEGIN TRANSACTION
DECLARE @userID int;
SELECT @userID = userID
FROM USERS
where userEmail = @_email;
    if exists(select 1
              from USERS
              where userEmail = @_email)
        begin
            if exists(select 1
                      from USERS
                      where userEmail = @_email
                        and password = @_password)
                begin
                    select r.roleName
                    from ROLE r,
                         USER_ROLE ur
                    where ur.userID = @userID
                      and r.roleID = ur.roleID
                      and ur.[default] = 1;
                    select userEmail username, userID, firstName, lastName from USERS where userEmail = @_email;

                    update USERS SET lastLogin = GETDATE() where userEmail = @_email
                    IF @@ROWCOUNT = 0 GOTO errorHandler;

                    COMMIT TRANSACTION
                    return 0;
                end
            else
                begin
                    ROLLBACK TRANSACTION
                    RETURN -3;
                end
        end
    else
        begin
            ROLLBACK TRANSACTION
            RETURN -2;
        end
    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure newhistory @_pon INT,
                            @_toni INT,
                            @_ban VARCHAR(20),
                            @_dan VARCHAR(20),
                            @_newtoni INT,
                            @_ton VARCHAR(40),
                            @_sec VARCHAR(40),
                            @_newton VARCHAR(40),
                            @_newsec VARCHAR(40)
AS
begin
    INSERT INTO [dbo].[CHANGINGHISTORY]
    ( [productID]
    , [submittedTime]
    , [preAcID]
    , [newAcID]
    , [doneBy]
    , [action]
    , [preAcName]
    , [newAcName]
    , [readStatus])
    VALUES ( @_pon
           , getdate()
           , @_toni
           , @_newtoni
           , @_ban
           , @_dan
           , (@_ton + ' ' + @_sec)
           , (@_newton + ' ' + @_newsec)
           , 'false')


end
go

CREATE procedure newreminder @_rem INT,
                             @_aoni INT,
                             @_aon VARCHAR(40),
                             @_sec VARCHAR(40),
                             @_kan VARCHAR(20),
                             @_wan VARCHAR(20)
AS
begin
    INSERT INTO [dbo].[CHANGINGHISTORY]
    ( [productID]
    , [submittedTime]
    , [exAcID]
    , [action]
    , [doneBy]
    , [exAcName]
    , [readStatus])
    VALUES ( @_rem
           , getdate()
           , @_aoni
           , @_wan
           , @_kan
           , (@_aon + ' ' + @_sec)
           , 'false')


end
go

CREATE PROCEDURE registerProduct @_productName varchar(40),
                                 @_category varchar(20),
                                 @_customerEmail varchar(50),
                                 @_projectManagerEmail varchar(50),
                                 @_accountCoordinatorEmail varchar(50),
                                 @_createdAdmin varchar(50),
                                 @_developers developers READONLY
AS
    BEGIN TRANSACTION
DECLARE @customerID int;
SELECT @customerID = userID
FROM USERS
where userEmail = @_customerEmail;

DECLARE @projectManagerID int;
SELECT @projectManagerID = userID
FROM USERS
where userEmail = @_projectManagerEmail;

DECLARE @accountCoordinatorID int;
SELECT @accountCoordinatorID = userID
FROM USERS
where userEmail = @_accountCoordinatorEmail;

DECLARE @createdAdminID int;
SELECT @createdAdminID = userID
FROM USERS
where userEmail = @_createdAdmin;

DECLARE
    developer_cursor CURSOR LOCAL FOR SELECT *
                                      FROM @_developers

DECLARE @productID int, @developerIDTemp INT;
    SET @productID = ((SELECT MAX(productID)
                       from PRODUCT) + 1);

    if (not exists(select 1
                   from USER_ROLE
                   where userID = @customerID
                     and roleID = 0))
        begin
            ROLLBACK TRANSACTION
            RETURN -2;
        end
    if (not exists(select 1
                   from USER_ROLE
                   where userID = @accountCoordinatorID
                     and roleID = 1))
        begin
            ROLLBACK TRANSACTION
            RETURN -3;
        end
    if (not exists(select 1
                   from USER_ROLE
                   where userID = @projectManagerID
                     and roleID = 3))
        begin
            ROLLBACK TRANSACTION
            RETURN -4;
        end
INSERT INTO PRODUCT
VALUES (iif(@productID is null, 1, @productID),
        @_productName,
        @_category,
        @customerID,
        @projectManagerID,
        @accountCoordinatorID,
        GETDATE(),
        @createdAdminID, null, null)
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    OPEN developer_cursor
    FETCH NEXT FROM developer_cursor INTO @developerIDTemp
    WHILE @@FETCH_STATUS = 0
        BEGIN
            if (not exists(select 1
                           from USER_ROLE
                           where userID = @developerIDTemp
                             and roleID = 2))
                begin
                    ROLLBACK TRANSACTION
                    RETURN -5;
                end
            INSERT INTO ALLOCATION VALUES (@developerIDTemp, @productID);
            IF @@ROWCOUNT = 0 GOTO errorHandler;
            FETCH NEXT FROM developer_cursor INTO @developerIDTemp
        END
    CLOSE developer_cursor

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE PROCEDURE registerUser @_firstname VARCHAR(40),
                              @_lastname VARCHAR(40),
                              @_email VARCHAR(50),
                              @_password VARCHAR(100),
                              @_roles roles READONLY,
                              @_contactNumber VARCHAR(20),
                              @_defaultRole INT,
                              @_createdAdmin VARCHAR(50),
                              @_clientOtp INT,
                              @_generatedOtpID INT
AS
    BEGIN TRANSACTION
DECLARE @userID int, @role INT, @generatedOTPValue int;

    SET @userID = ((SELECT MAX(userID)
                    from USERS) + 1);
SELECT @generatedOTPValue = otpCode
FROM OTP
where otpID = @_generatedOtpID;
-- delete otp record from the OTP table
Delete
from OTP
where otpID = @_generatedOtpID
    IF @@ROWCOUNT = 0 GOTO errorHandler;

DECLARE
    role_cursor CURSOR LOCAL FOR SELECT *
                                 FROM @_roles
    if (@_clientOtp != @generatedOTPValue)
        begin
            ROLLBACK TRANSACTION
            return -2;
        end
    else
        if exists(select 1 from USERS where userEmail = @_email)
            begin
                ROLLBACK TRANSACTION
                return -3;
            end
INSERT INTO USERS
VALUES (iif(@userID is null, 1, @userID),
        @_email,
        @_password,
        @_firstname,
        @_lastname,
        @_contactNumber,
        1,
        null,
        @_createdAdmin,
        GETDATE(),
        null,
        null);
    IF @@ROWCOUNT = 0 GOTO errorHandler;

    OPEN role_cursor
    FETCH NEXT FROM role_cursor INTO @role
    WHILE @@FETCH_STATUS = 0
        BEGIN
            IF @role = @_defaultRole
                BEGIN
                    INSERT INTO USER_ROLE VALUES (iif(@userID is null, 1, @userID), @role, 1);
                END
            ELSE
                BEGIN
                    INSERT INTO USER_ROLE VALUES (iif(@userID is null, 1, @userID), @role, 0);
                END

            FETCH NEXT FROM role_cursor INTO @role
        END
    CLOSE role_cursor

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure roleChange @_username VARCHAR(50),
                            @_requestedRole VARCHAR(25)
as
DECLARE @userID int;
SELECT @userID = userID
FROM USERS
where userEmail = @_username;
    if exists(select 1
              from USER_ROLE ur
                       join ROLE r on r.roleID = ur.roleID
              where ur.userID = @userID
                and r.roleName = @_requestedRole)
        begin
            select r.roleName
            from ROLE r
                     join USER_ROLE ur on r.roleID = ur.roleID
            where ur.userID = @userID
              and r.roleName = @_requestedRole;
            select userEmail username, userID from USERS where userEmail = @_username;
            return 0;
        end
    else
        begin
            return -1;
        end
go

CREATE PROCEDURE saveAndReturnOTP @_generatedOTP int
AS
    BEGIN TRANSACTION
DECLARE
    @maxOtpID int,
    @otpID    int;
    SET @maxOtpID = ((SELECT MAX(otpID)
                      from OTP) + 1);
    SET @otpID = iif(@maxOtpID is null, 1, @maxOtpID)
INSERT INTO OTP
VALUES (@otpID,
        @_generatedOTP)
    IF @@ROWCOUNT = 0 GOTO errorHandler;
SELECT otpID
FROM OTP
where otpID = @otpID
    COMMIT TRANSACTION
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE PROCEDURE saveComment @_senderEmail varchar(50),
                             @_complaintID int,
                             @_text varchar(MAX),
                             @_noOfImages int
AS
    BEGIN TRANSACTION
DECLARE @senderID int;
SELECT @senderID = userID
FROM USERS
where userEmail = @_senderEmail;

DECLARE @currentMaxCommentID int;
DECLARE @commentID int;
    SET @currentMaxCommentID = (SELECT MAX(commentID)
                                from COMMENT
                                where complaintID = @_complaintID) ;
    SET @commentID = iif(@currentMaxCommentID is null, 1, @currentMaxCommentID + 1);
    IF (@_text != '')
        BEGIN
            INSERT INTO COMMENT
            VALUES (@_complaintID,
                    @commentID,
                    0,
                    @_text,
                    @senderID,
                    GETDATE(),
                    0)
            IF @@ROWCOUNT = 0 GOTO errorHandler;
        end
    SET @currentMaxCommentID = (SELECT MAX(commentID)
                                from COMMENT
                                where complaintID = @_complaintID) ;
    SET @commentID = iif(@currentMaxCommentID is null, 1, @currentMaxCommentID + 1);
DECLARE @i int;
    SET @i = 0;
    WHILE @i < @_noOfImages
        BEGIN
            SET @i = @i + 1
            /* your code*/
            INSERT INTO COMMENT
            VALUES (@_complaintID, @commentID, 1, TRIM(STR(@_complaintID)) + '-' + TRIM(STR(@commentID)) + '.png',
                    @senderID, GETDATE(), 0)
            IF @@ROWCOUNT = 0 GOTO errorHandler;
            SELECT * FROM COMMENT where complaintID = @_complaintID and commentID = @commentID
            SET @commentID = @commentID + 1
        END

    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure updateAccountCoordinator @_cbc INT,
                                          @_pdi INT
AS
begin
    UPDATE [dbo].[PRODUCT] SET [accountCoordinatorID] =@_cbc WHERE productID = @_pdi

end
go

CREATE procedure updateOrCreateSession @userID int,
                                       @lastActive BIGINT as
    begin transaction
    if (exists(select 1
               from ACTIVE_SESSION
               where userID = @userID))
        begin
            update ACTIVE_SESSION set lastActive = @lastActive where userID = @userID
            IF @@ROWCOUNT = 0 GOTO errorHandler;
        end
    else
        begin
            insert into ACTIVE_SESSION values (@userID, @lastActive)
            IF @@ROWCOUNT = 0 GOTO errorHandler;
        end
    commit transaction
    return 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure updateProjectManger @_cbc INT,
                                     @_pdi INT
AS
begin
    UPDATE [dbo].[PRODUCT] SET [projectManagerID] =@_cbc WHERE productID = @_pdi

end
go

CREATE procedure updateReadStatus @_time varchar(50)
AS

begin
    UPDATE [dbo].[CHANGINGHISTORY]
    SET [readStatus] ='true'
    where submittedtime = @_time
end
go

CREATE procedure updateSelectedUserDetails @_oldEmail VARCHAR(50),
                                           @_firstname VARCHAR(40),
                                           @_lastname VARCHAR(40),
                                           @_newEmail VARCHAR(50),
                                           @_password VARCHAR(20),
                                           @_roles roles READONLY,
                                           @_contactNumber VARCHAR(20),
                                           @_defaultRole INT,
                                           @_modifiedAdmin VARCHAR(50),
                                           @_clientOtp INT,
                                           @_generatedOtpID INT
AS
    BEGIN TRANSACTION
DECLARE @userID int, @userIDTemp int, @roleID int, @role INT, @generatedOTPValue int;

SELECT @userID = userID
FROM USERS
where userEmail = @_oldEmail;

DECLARE
    cursor_email CURSOR LOCAL FOR SELECT userID, roleID
                                  FROM USER_ROLE
                                  WHERE userID = @userID
DECLARE
    role_cursor CURSOR LOCAL FOR SELECT *
                                 FROM @_roles
    if (@_oldEmail != @_newEmail)
        begin
            SELECT @generatedOTPValue = otpCode FROM OTP where otpID = @_generatedOtpID;
            -- delete otp record from the OTP table
            Delete from OTP where otpID = @_generatedOtpID
            IF @@ROWCOUNT = 0 GOTO errorHandler;

            if (@_clientOtp != @generatedOTPValue)
                begin
                    ROLLBACK TRANSACTION
                    return -2;
                end
            else
                if (exists(select 1 from USERS where userEmail = @_newEmail))
                    begin
                        ROLLBACK TRANSACTION
                        return -3;
                    end

        end

    OPEN cursor_email
    fetch next from cursor_email into @userIDTemp, @roleID
    while @@fetch_status = 0
        begin
            delete from USER_ROLE where userID = @userIDTemp AND roleID = @roleID
            IF @@ROWCOUNT = 0 GOTO errorHandler;

            fetch next from cursor_email into @userIDTemp, @roleID
        end
    CLOSE cursor_email
UPDATE USERS
SET userEmail    = @_newEmail,
    firstName    = @_firstname,
    lastName     = @_lastname,
    password     = @_password,
    contactNumber= @_contactNumber,
    modifiedBy   = @_modifiedAdmin,
    modifiedAt   = GETDATE()
WHERE userEmail = @_oldEmail;
    IF @@ROWCOUNT = 0 GOTO errorHandler;


    OPEN role_cursor
    FETCH NEXT FROM role_cursor INTO @role
    WHILE @@FETCH_STATUS = 0
        BEGIN
            IF @_defaultRole = null
                BEGIN
                    GOTO errorHandler;
                END
            ELSE
                IF @role = @_defaultRole
                    BEGIN
                        INSERT INTO USER_ROLE VALUES (@userID, @role, 1);
                        IF @@ROWCOUNT = 0 GOTO errorHandler;
                    END
                ELSE
                    BEGIN
                        INSERT INTO USER_ROLE VALUES (@userID, @role, 0);
                        IF @@ROWCOUNT = 0 GOTO errorHandler;
                    END

            FETCH NEXT FROM role_cursor INTO @role
        END
    CLOSE role_cursor

SELECT *
from USERS
where userEmail = @_newEmail
    COMMIT TRANSACTION;
    RETURN 0;

    errorHandler:
    ROLLBACK TRANSACTION
    RETURN -1;
go

CREATE procedure userToolbarDetails @_username VARCHAR(50)
as
DECLARE @userID int;
SELECT @userID = userID
FROM USERS
where userEmail = @_username;
    if exists(select 1
              from USERS
              where userEmail = @_username)
        begin
            select firstName from USERS where userEmail = @_username

            select r.roleName
            from ROLE r,
                 USER_ROLE ur
            where ur.userID = @userID
              and r.roleID = ur.roleID;

            select r.roleName defaultRole
            from ROLE r,
                 USER_ROLE ur
            where ur.userID = @userID
              and r.roleID = (
                select roleID from USER_ROLE where USER_ROLE.userID = @userID and [default] = 'true');

            return 0;
        end
    else
        begin
            return -1;
        end
go

